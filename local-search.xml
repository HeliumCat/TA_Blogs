<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>视差映射</title>
    <link href="/TA_Blogs/2023/12/31/%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/"/>
    <url>/TA_Blogs/2023/12/31/%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="最简单版本的视差映射-Parallax-Mapping"><a href="#最简单版本的视差映射-Parallax-Mapping" class="headerlink" title="最简单版本的视差映射(Parallax Mapping)"></a>最简单版本的视差映射(Parallax Mapping)</h2><p>我个人对于视差映射这个东西其实理解了很久，因为网上大部分的博客和资料都没有点明一件事，那就是视差映射这个东西实际上是一个非常经验性的trick，而不是有多少数学上的严谨在里面的。这导致我一直在试图从几何上理解那一套得到uv的offset的过程，结果一直没有想通，后来干脆尝试直接从合理性的角度去理解这一套过程(就是强行解释…)，反倒茅塞顿开。<br>以下是我个人对于视差映射的理解：</p><h3 id="视差映射是为了解决啥问题？"><a href="#视差映射是为了解决啥问题？" class="headerlink" title="视差映射是为了解决啥问题？"></a>视差映射是为了解决啥问题？</h3><p>普通的贴图+法线贴图固然效果已经还算可以接受了，但是这个方案的缺点在于法线贴图这个东西本质上只修改了一个表面的着色信息(法线)，而无法照顾到因为表面凹凸造成的遮挡问题(几何信息)。位移贴图确实可以解决遮挡问题，但是位移贴图对模型的面数有要求，或者位移完做个曲面细分，无论怎么样都需要模型拥有更多的面数，这样增加了性能的开销。  </p><div class="note note-info">            <p>更多的模型细节必然伴随更多的三角形，不可能通过位移顶点白嫖模型细节的呀</p>          </div><p>所以，视差映射这种高级的trick就出来了，其思想就是：<strong>所谓的遮挡，实际上可以看成【被遮挡部分】的贴图被【遮挡部分】的贴图所取代。如何取代呢？就像抹颜料一样，把【遮挡部分】的贴图抹过去</strong>，不完全准确，再借知乎上一个老哥的图来说就是这样：<br><img src="/TA_Blogs/2023/12/31/%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/image-1.png" alt="视差贴图的一种理解&lt;sup id=&quot;fnref:1&quot; class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--rounded&quot; aria-label=&quot;https://zhuanlan.zhihu.com/p/574361162&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;"><br>所谓的y轴范围着色就是这种“把颜料抹过去”的感觉。不过这张图我有个不太接受的说法就是视差映射增加了着色信息。总体的着色信息我认为是没有变的，改变的只有纹理映射的方式。</p><h3 id="视差映射用到了什么？"><a href="#视差映射用到了什么？" class="headerlink" title="视差映射用到了什么？"></a>视差映射用到了什么？</h3><p>简单来考虑，一个几何平面，一张普通的表面贴图，可能还有法线贴图(加了这玩意效果更好)，然后就是一张视差贴图(这个是关键)，视差贴图其实就是高度图做了一个颜色反转，实际上使用的是高度信息。大概长下面这个样子：<br><img src="/TA_Blogs/2023/12/31/%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/image.png" alt="视差贴图"><br>这个视差贴图实际上是一个砖墙的，可以看出突出的部分是黑色(0)，凹陷的地方是白色(1)，先记住这一点很关键。</p><h3 id="如何使用视差贴图？"><a href="#如何使用视差贴图？" class="headerlink" title="如何使用视差贴图？"></a>如何使用视差贴图？</h3><p>从LearnOpenGL上偷了张图：<br><img src="/TA_Blogs/2023/12/31/%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/image-2.png" alt="视差贴图原理"><br>从图中可以看出，B指向A的向量是我们的视线方向，红色不规则的曲线是高度图(视差贴图取反)的高度，B是视线与这个假想高度的交点，A是视线与平面的交点。如果没有视差映射，我们想要显示的就是A点的纹理，但是由于加入了视差映射，按理说整个区域的纹理都该向图中左边的方向偏移，从纹理坐标上反映就是A点的纹理坐标应该对应原本图中右边的点的纹理坐标。这个偏移值(offset)如何确定？实际上这里做了一个假设，就是<br><strong>假设A点的纹理坐标需要对应到B点投影到平面上那个点的纹理坐标</strong><br>不管从可行性还是性能上考虑我们都不可能算出B点的坐标然后投影。所以这里采用了一种替代的方法求出从A指向B的向量P，将P在平面上的投影作为偏移。具体在fragment shader实现，采用切线空间计算，大概的代码就是长这样：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//我们定义了一个叫做ParallaxMapping的函数，它把fragment的纹理坐标和切线空间中的fragment到观察者的方向向量为输入。</span><br><span class="hljs-comment">//这个函数返回经位移的纹理坐标。然后我们使用这些经位移的纹理坐标进行diffuse和法线贴图的采样。</span><br><span class="hljs-comment">//最后fragment的diffuse颜色和法线向量就正确的对应于表面的经位移的位置上了。</span><br><br><span class="hljs-comment">//我们来看看ParallaxMapping函数的内部：</span><br><span class="hljs-type">vec2</span> ParallaxMapping(<span class="hljs-type">vec2</span> texCoords, <span class="hljs-type">vec3</span> viewDir)<br>&#123; <br>    <span class="hljs-comment">//这里采样了视差贴图，只取r分量的原因是视差贴图本来只有灰度信息</span><br>    <span class="hljs-type">float</span> height =  <span class="hljs-built_in">texture</span>(depthMap, texCoords).r;<br>    <span class="hljs-comment">//这里为什么这么算在下面详细解释</span><br>    <span class="hljs-type">vec2</span> p = viewDir.xy / viewDir.z * (height * height_scale);<br>    <span class="hljs-comment">//这里加或者减会改变最终视觉上倾斜的方向，可以自己试</span><br>    <span class="hljs-keyword">return</span> texCoords - p;    <br>&#125;<br></code></pre></td></tr></table></figure><p>这里，<code>viewDir.xy</code>很明显就是p在平面上投影的方向，除以<code>viewDir.z</code>的原因可以想象一下我们的视线越与平面垂直，需要的偏移量越小，视线越与平面平行，需要的偏移量越大，这里除以z其实就是这个作用。然后为啥要乘以height呢？因为视差贴图这样定义高度：<br><img src="/TA_Blogs/2023/12/31/%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/image-3.png" alt="视差贴图定义的高度"><br>可以看到，越突出<code>height</code>越接近0，越平<code>height</code>越接近1，因为如果A点原本就是山峰，我们就无需计算它的纹理坐标偏移，因为它本身就是遮挡别人的，<code>height</code>为0最终得出来的<code>p</code>也为0向量。最后我们还乘了一个<code>height_scale</code>是为了能自己调视差效果的强度。<br>总结：</p><ul><li>视差映射其实和Blinn-Phong光照模型类似，是一个经验性的算法，不要想的太复杂</li><li>视差映射只是尝试去模拟凹凸，并没有改变几何信息。</li></ul><p>然而到这里其实还没有结束，我们注意到成品还有一些瑕疵，如图：<br><img src="/TA_Blogs/2023/12/31/%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/image-4.png" alt="法线贴图vs视差映射"><br>右图的边缘还是有一些看着不和谐的地方，这是因为边缘的uv坐标经过这么一映射，有些超过1或者有些小于0了，只需要做个判断即可：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs glsl">texCoords = ParallaxMapping(fs_in.TexCoords,  viewDir);<br><span class="hljs-keyword">if</span>(texCoords.x &gt; <span class="hljs-number">1.0</span> || texCoords.y &gt; <span class="hljs-number">1.0</span> || texCoords.x &lt; <span class="hljs-number">0.0</span> || texCoords.y &lt; <span class="hljs-number">0.0</span>)<br>    <span class="hljs-keyword">discard</span>;<br></code></pre></td></tr></table></figure><p>最终结果：<br><img src="/TA_Blogs/2023/12/31/%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/image-5.png" alt="视差映射"></p><h2 id="陡峭视差映射"><a href="#陡峭视差映射" class="headerlink" title="陡峭视差映射"></a>陡峭视差映射</h2><p>&#x2F;&#x2F;———————–施工中——————————-&#x2F;&#x2F;</p><h2 id="视差屏蔽映射"><a href="#视差屏蔽映射" class="headerlink" title="视差屏蔽映射"></a>视差屏蔽映射</h2><p>&#x2F;&#x2F;———————–施工中——————————-&#x2F;&#x2F;</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/574361162">https://zhuanlan.zhihu.com/p/574361162</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>材质</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/TA_Blogs/2023/12/30/hello-world/"/>
    <url>/TA_Blogs/2023/12/30/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
