<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>游戏编程模式(二) 命令模式</title>
    <link href="/2024/02/03/Design-Patterns/Command/"/>
    <url>/2024/02/03/Design-Patterns/Command/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>GoF这么描述命令模式：</p><blockquote><p>Encapsulate a request as an object, thereby letting users parameterize clients with different requests, queue or log requests, and support undoable operations.</p></blockquote><p>这段话其实看的人一头雾水，我觉得比较重要的点就是：将请求封装为对象以及这样做可以实现撤销操作功能。<br>这本书的作者也给出了他认为的命令模式：  </p><blockquote><p>A command is a reified method call</p></blockquote><p>reified的意思是“具象化的，实物化的”，上面这句话表达的意思也就是命令是一个实例化的方法。这听起来像是回调函数那一类的东西，因此GoF补充道：  </p><blockquote><p>Commands are an object-oriented replacement for callbacks.</p></blockquote><p>这下感觉清楚多了，命令模式其实就是将回调函数的面向对象表达。</p><h2 id="解决的痛点"><a href="#解决的痛点" class="headerlink" title="解决的痛点"></a>解决的痛点</h2><ol><li>游戏中需要将按键绑定为对应的功能，如果直接将功能写为函数，再强行绑到对应的按键上，以后如果需要修改按键映射就特别麻烦。</li><li>游戏的回放功能，命令撤销功能等如何实现。</li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>索引</tag>
      
      <tag>Series</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Plan</title>
    <link href="/2024/01/31/Plan/"/>
    <url>/2024/01/31/Plan/</url>
    
    <content type="html"><![CDATA[<h2 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h2><h3 id="2024年1月-2月"><a href="#2024年1月-2月" class="headerlink" title="2024年1月-2月"></a>2024年1月-2月</h3><div>            <input type="checkbox"  >游戏编程模式          </div><div>            <input type="checkbox"  >Unity Shader入门精要          </div><div>            <input type="checkbox"  >Unity脚本          </div><div>            <input type="checkbox"  >2D随机地图生成教程          </div><div>            <input type="checkbox"  >VFX教程          </div><h2 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h2><div>            <input type="checkbox"  >cinemachine          </div><div>            <input type="checkbox"  >dotween          </div><div>            <input type="checkbox"  >屏幕破碎效果          </div><div>            <input type="checkbox"  >时间停止效果          </div><div>            <input type="checkbox"  >UE交互雪地[tx游戏学堂](前置：gamedev.tv UE基础)          </div><div>            <input type="checkbox"  >死亡搁浅扫描效果          </div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>游戏编程模式(一) 总览</title>
    <link href="/2024/01/28/Design-Patterns/Design-Patterns-Overview/"/>
    <url>/2024/01/28/Design-Patterns/Design-Patterns-Overview/</url>
    
    <content type="html"><![CDATA[<h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>刚开始接触实际的Untiy项目，首先感受到的第一件事就是要回去好好看看设计模式了，如果不去回顾参透一下设计模式写出来的代码就是依托答辩。<br>但是市面上关于设计模式的书和资料实在是太多了，只能说这个话题过于经典，不得不品尝。真正能用在游戏中的设计模式有多少呢？我其实也不太想去看比较经典的那本head first设计模式，不知道为什么每次看这大部头都看一点就看不下去，可能设计模式这种东西如果不是真正自己去用的话，学习中的正反馈也少，学完了也容易忘，而且这本我印象中好像示例代码是JAVA，看着生理不适（叠个甲，本人对于一切编程语言同等尊重，只是个人不太喜欢看JAVA的代码，并非抨击JAVA这个语言，望周知）（倒也不是不能看）（再叠个甲，本人知道看设计模式的书关注点不该在示例代码采用的语言上，望周知），就一直没能看下去。<br>然后我就发现了这本《游戏编程模式》，本来觉得这个名字沾点噱头，但是实际上确实书如其名，内容都是爷爱看的，是本好书。顺便一提这本书在网上公开了正版英文完整版和中文完整版，真为爱发电啊(爱游戏的都是好人捏)，不仅满昏我还要买实体收藏。  </p><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>CoF设计模式按照类别来分有3大类：</p><ul><li>创建型(Creational)：用于创建对象</li><li>结构型(Structural)：用于处理类或对象之间的关系</li><li>行为型(Behavioral)：用于规范类或对象之间的交互<br>顺便一提，这里描述中的“类”和“对象”的确是区分开含义的，“对象”指的实例。</li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>设计模式讨论的重点其实就是软件架构，而架构的存在是为了改动代码。也就是说，代码如果以后不做任何改动，架构设计就是没有意义的。所以设计架构，就是考虑以后改动的可能性而做的冗余设计。  </p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>既然是冗余的设计，那么直觉上大部分这样的设计其实是影响性能的。因为不仅代码量增加了，而且很多时候需要用到动态分派(Dynamic Dispatch)，也就是虚函数那块的东西来实现多态。所以说设计架构的时候其实比较容易陷入架构的陷阱。在设计时需要谨慎考虑哪里需要预留灵活性，哪里不需要。</p><h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p>人的大脑其实内存和缓存是有限的，写程序的时候把“上下文”完整装入大脑是很困难的，所以说我们需要减少写一段程序所需要的“上下文”内容，这就是解耦。解耦不仅可以让我们只关注当前所要实现的内容，而不必关心其他部分。同时，需要对写好的代码做出修改时，可以尽可能少的变动代码来达到目的。  </p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>原型即“不考虑任何架构，上来就写，目的是实现功能”的代码。这样的代码是知道将会扔掉的。但是原型可以快速帮我们验证功能的可行性，所以编写原型也是有用的。  </p><h3 id="蒸干代码"><a href="#蒸干代码" class="headerlink" title="蒸干代码"></a>蒸干代码</h3><p>臻于完美之时，不是加无可加，而是减无可减。写完代码后，需要对代码进行清理保证简洁，这样也能达到“减少需要考虑的上下文”的作用。</p><h3 id="鸡汤"><a href="#鸡汤" class="headerlink" title="鸡汤"></a>鸡汤</h3><p>如果你想要做出让人享受的东西，那就享受做它的过程。</p><p>《游戏编程模式》中只讲了CoF设计模式中对游戏开发有用的几个模式，另外作者还提出了自己的4种类型的设计模式：序列模式、行为模式、解耦模式、优化模式。接下来按书中的顺序列举设计模式并给出对应文章链接(没链接就是还没写，摸了)：</p><h2 id="CoF设计模式"><a href="#CoF设计模式" class="headerlink" title="CoF设计模式"></a>CoF设计模式</h2><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>类型：行为型<br>概括：</p><ul><li>将具体方法封装为类，从而解除具体方法与调用方的耦合。(如游戏中的按键动态绑定)</li><li>调用方获取类的实例并且延迟执行，从而解除调用方和具体对象(这里指调用方原本想操控的对象)的耦合。(如游戏中命令作用到不同的对象(玩家，怪物))<br>点击跳转到文章：<a href="/2024/02/03/Design-Patterns/Command/" title="游戏编程模式(二) 命令模式">命令模式</a></li></ul><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>类型：结构型<br>概括：共享重复的部分</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>类型：行为型<br>概括：发生事件，通知订阅者</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>索引</tag>
      
      <tag>Series</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gabriel Aguiar的VFX系列(二) 火花</title>
    <link href="/2024/01/23/VFX/Gabriel-Aguiar-Series/VFX-Sparks/"/>
    <url>/2024/01/23/VFX/Gabriel-Aguiar-Series/VFX-Sparks/</url>
    
    <content type="html"><![CDATA[<p>火花算比较简单的VFX效果，只有一个阶段，并且用不上一些复杂的贴图和技术，基本上只需要调一调粒子系统里面的参数即可。但是实际上我在制作火花效果的时候犯了一个低级错误卡了很久，姑且记录一下引以为戒。  </p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>使用Unity新建一个项目，在场景中放置一个空物体，上面挂一个particle system。可以看到默认的particle system在发射一些材质丢失的粒子，我们需要为粒子系统添加有效的材质。</p><h2 id="贴图制作"><a href="#贴图制作" class="headerlink" title="贴图制作"></a>贴图制作</h2><p>首先Unity其实是给粒子创建了一个默认的贴图的，长下面这样：<br><img src="/2024/01/23/VFX/Gabriel-Aguiar-Series/VFX-Sparks/image.png" alt="Unity内置粒子贴图"><br>但是大部分情况下，需要自己来制作这类贴图。</p><div class="note note-info">            <p>人类是有极限的，JOJO!!!!!!!<br>不是学美术的感觉对制作贴图这块多少都会有点头疼，虽然一部分贴图的制作不是很难，甚至可以直接抄，但是感觉还是限制了思维。希望以后能培养出来这方面的直觉和能力，毕竟这才是TA的上限。</p>          </div><p>对于最普通的这种粒子贴图，其实使用PhotoShop可以很轻松地做出来。具体做法：  </p><ul><li>打开PhotoShop，创建一个1000*1000像素的画布</li><li>把背景图层涂黑</li><li>创建一个新图层</li><li>把画笔的硬度调为0，不透明度拉满，大小调为500，在新图层上点一个白色的点</li><li>选中这两个图层，按V，将这两个图层左右上下对齐</li><li>导出最上面的图层，收工<br>众所周知贴图是不能直接用的，我们需要使用shaderGraph创建shader和材质。</li></ul><h2 id="ShaderGraph"><a href="#ShaderGraph" class="headerlink" title="ShaderGraph"></a>ShaderGraph</h2><p>连连看如下所示：<br><img src="/2024/01/23/VFX/Gabriel-Aguiar-Series/VFX-Sparks/image-1.png" alt="ShaderGraph连连看"><br>这里之前踩了一个坑，就是千万要注意这个颜色属性的alpha通道的值默认是0，导致multiply之后所有的alpha都变为0了，最终出现渲染出来全部透明，还半天找不到原因。需要将颜色属性的alpha通道改为255。</p><h2 id="Particle-System"><a href="#Particle-System" class="headerlink" title="Particle System"></a>Particle System</h2><p>Particle System的调参才是重头戏。(但是并不是我花时间最多的，悲:&lt;)<br>这一部分可能描述的有点乱，很多通用的东西是穿插在特例里面描述的，而且我想到哪就写到哪，捏着鼻子看吧  </p><h3 id="持续的spark"><a href="#持续的spark" class="headerlink" title="持续的spark"></a>持续的spark</h3><p>这个VFX由3个部分组成：</p><ul><li>Sparks</li><li>Beam</li><li>Shiny<br>效果如下：<br><img src="/2024/01/23/VFX/Gabriel-Aguiar-Series/VFX-Sparks/spark_loop.gif" alt="持续火花"></li></ul><h4 id="Sparks"><a href="#Sparks" class="headerlink" title="Sparks"></a>Sparks</h4><h5 id="基础参数"><a href="#基础参数" class="headerlink" title="基础参数"></a>基础参数</h5><p><img src="/2024/01/23/VFX/Gabriel-Aguiar-Series/VFX-Sparks/image-2.png" alt="基础参数"><br>Unity的粒子系统里面大部分可以填数字的地方一般都有4个选项：  </p><ul><li>Constant</li><li>Curve(如果是颜色的话就是Gradiant)</li><li>Random between two Constant</li><li>Random between two Curve<br>这几个其实就是字面上的意思，如果是Curve的话就是随着Duration按照Curve来变化(注意这里是Duration而不是Lifetime，这一点非常重要，下面会详细解释)。然后Random就是在两个值之间的范围内随机，很好理解。<br>这个例子中为什么Start Color不是关键属性呢，实际上是因为我们需要这个粒子特效在一个粒子的生命周期(Lifetime)内变化颜色，对应下方的Color over Lifetime组件中设置的内容。这里我在刚学的时候产生了一个疑惑(脑子抽了)，那就是Start Color设置为Gradiant类型和直接设置Color over Lifetime有啥区别？实际上，Gradiant类型的Start Color指的是在粒子生成的时候，生成的初始颜色会随着Gradiant变化。而Color over Lifetime是生成之后一个粒子随着它自己的生命周期改变颜色。<br>这里顺便科普下Gradiant界面这些都是啥玩意：<br><img src="/2024/01/23/VFX/Gabriel-Aguiar-Series/VFX-Sparks/image-3.png" alt="Gradiant"><br>之后的simulation space决定了粒子的物理效果在局部坐标系进行模拟还是世界坐标系进行模拟。举个例子，如果是局部坐标系模拟的话，如果粒子系统在场景中发生了运动就会穿帮，因为粒子是感受不到场景的，已经发射出去的粒子因为粒子系统的移动也会跟着移动。而如果是世界坐标系的话，已经发射出去的粒子不再受粒子系统移动的影响。<br>既然说到了模拟，gravity modifier这个属性是影响粒子的重力的，这里设为1是和引擎中设置的重力同步。</li></ul><h5 id="Emission"><a href="#Emission" class="headerlink" title="Emission"></a>Emission</h5><p><img src="/2024/01/23/VFX/Gabriel-Aguiar-Series/VFX-Sparks/image-4.png" alt="Emission"><br>粒子系统的重要组成部分，用来发射粒子。<br>如果发射是需要持续一段时间的，那就用rate over time。<br>如果是爆炸效果，就在burst里面加值。</p><h5 id="Shape"><a href="#Shape" class="headerlink" title="Shape"></a>Shape</h5><p><img src="/2024/01/23/VFX/Gabriel-Aguiar-Series/VFX-Sparks/image-5.png" alt="Shape"><br>发射区域的形状，决定在多大的范围内生成粒子。</p><h5 id="下面的一大堆组件"><a href="#下面的一大堆组件" class="headerlink" title="下面的一大堆组件"></a>下面的一大堆组件</h5><p>包括xx over Lifetime， xx over Speed之类的都是字面意思，自己去体会。这个例子中，设置了两个：<br><img src="/2024/01/23/VFX/Gabriel-Aguiar-Series/VFX-Sparks/image-6.png" alt="生命周期">  </p><h5 id="Collision"><a href="#Collision" class="headerlink" title="Collision"></a>Collision</h5><p><img src="/2024/01/23/VFX/Gabriel-Aguiar-Series/VFX-Sparks/image-7.png" alt="Collision"><br>这里需要把碰撞的类型设置为World，这样粒子就会与场景中有碰撞体的物体发生碰撞了。</p><h5 id="Renderer"><a href="#Renderer" class="headerlink" title="Renderer"></a>Renderer</h5><p><img src="/2024/01/23/VFX/Gabriel-Aguiar-Series/VFX-Sparks/image-9.png" alt="Renderer"><br>这里就把Render Mode设置为Stretched Billboard就行，是一个拉长的广告牌效果<br><img src="/2024/01/23/VFX/Gabriel-Aguiar-Series/VFX-Sparks/image-8.png" alt="材质属性"><br>懂的都懂</p><h4 id="Beam"><a href="#Beam" class="headerlink" title="Beam"></a>Beam</h4><p>把上面的Sparks复制一份，改改，就不细说了只挑重点。<br><img src="/2024/01/23/VFX/Gabriel-Aguiar-Series/VFX-Sparks/image-10.png" alt="Beam"><br>注意size over lifetime那个曲线是自己调的，让Beam在生命周期里面一会大一会小，但是生命周期又特别短，那就是疯狂抽动，表现出那种火光的效果。</p><h4 id="Shiny"><a href="#Shiny" class="headerlink" title="Shiny"></a>Shiny</h4><p><img src="/2024/01/23/VFX/Gabriel-Aguiar-Series/VFX-Sparks/image-11.png" alt="Shiny"><br>shiny部分更简单，就是模拟一个中心点迸发的效果，主要就是start rotation这块让粒子生成的初期随机在范围内旋转一个角度。每个粒子都是一个细长条。</p><h3 id="类似敲击的spark"><a href="#类似敲击的spark" class="headerlink" title="类似敲击的spark"></a>类似敲击的spark</h3><p>效果如下：<br><img src="/2024/01/23/VFX/Gabriel-Aguiar-Series/VFX-Sparks/spark_hit.gif" alt="敲击火花">  </p><h4 id="Sparks-1"><a href="#Sparks-1" class="headerlink" title="Sparks"></a>Sparks</h4><p><img src="/2024/01/23/VFX/Gabriel-Aguiar-Series/VFX-Sparks/image-12.png" alt="Sparks"><br>和上一个效果没啥区别，主要就是将Emission部分换成了burst发射。将Shape部分换成了一个半球区域。</p><h4 id="Beam-1"><a href="#Beam-1" class="headerlink" title="Beam"></a>Beam</h4><p><img src="/2024/01/23/VFX/Gabriel-Aguiar-Series/VFX-Sparks/image-13.png" alt="Beam"><br>只产生一个，并且随着时间变小。</p><h4 id="Shiny-1"><a href="#Shiny-1" class="headerlink" title="Shiny"></a>Shiny</h4><p><img src="/2024/01/23/VFX/Gabriel-Aguiar-Series/VFX-Sparks/image-14.png" alt="Shiny"><br>只产生一簇，并且随着时间变小。</p><h4 id="Flash"><a href="#Flash" class="headerlink" title="Flash"></a>Flash</h4><p><img src="/2024/01/23/VFX/Gabriel-Aguiar-Series/VFX-Sparks/image-15.png" alt="Flash"><br>这个效果是比Beam更大一点的，更透明一点，更淡一点的效果。主要是模拟消散的外层火焰，color over lifetime的alpha从50开始降到0。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>通过改变Spark的颜色可以使这些爆炸效果具有完全不同的视觉感受，至于具体怎么配色那就属于个人审美了。</p>]]></content>
    
    
    <categories>
      
      <category>图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VFX</tag>
      
      <tag>Gabriel Aguiar入门教程</tag>
      
      <tag>Series</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gabriel Aguiar的VFX系列(一) VFX基本直觉</title>
    <link href="/2024/01/18/VFX/Gabriel-Aguiar-Series/VFX-Principles/"/>
    <url>/2024/01/18/VFX/Gabriel-Aguiar-Series/VFX-Principles/</url>
    
    <content type="html"><![CDATA[<h2 id="VFX类型"><a href="#VFX类型" class="headerlink" title="VFX类型"></a>VFX类型</h2><p>VFX这个东西其实类型非常单调，基本上就是shader、粒子效果、网格效果、贴图动画的组合。<br>这个部分其实没啥好说的，主要就是建立一个直觉，以及引发一下何为VFX的思考，因为很多VFX也有网格，那为什么不被定义为模型？显然，“有网格的VFX”与几何模型的最主要的区别就是VFX有明显的生命周期以及生命周期的几个阶段，这里就引出下面的VFX五要素。</p><h2 id="VFX五要素"><a href="#VFX五要素" class="headerlink" title="VFX五要素"></a>VFX五要素</h2><p>构成VFX的五大基本要素，每一项都决定了一个VFX的不同之处。</p><h3 id="GamePlay"><a href="#GamePlay" class="headerlink" title="GamePlay"></a>GamePlay</h3><p>说到底VFX还是为GamePlay服务的，在制作一个VFX之前需要知道具体的需求是什么。<br>这里可能说的有点笼统，但是确实是很关键的一件事，只有明确了这一点，才能决定剩下的几个要素。<br>比如是爆炸效果还是治愈效果，决定了效果的持续时间、对比度、形状、调色板等，有时这些需求区别比较大，比如这个例子，但是有一些需求之间的区分就需要仔细斟酌了，比如水和冰，火和岩浆，黄金和蜂蜜这些视觉表现如何做出区分。<br>从大的方向来看，按照逻辑效果来分有伤害类型和治愈类型 按照依附对象来分有环境类型和角色类型等等</p><h3 id="Timing"><a href="#Timing" class="headerlink" title="Timing"></a>Timing</h3><p>所谓的Timing其实就是一个VFX的生命周期，这个很好理解。爆炸特效的生命周期基本都很短，而一些环境光效，治疗效果之类的生命周期大部分都比较长。总体上来说，一个短生命周期的VFX分为以下几个阶段：</p><ul><li>Anticipation</li><li>Climax</li><li>Dissipation<br>这三个阶段都非常有意思。因为最近在玩DOTA2，举个比较经典的例子就是DOTA2卡尔的天火。写这篇文章之前没有仔细看过，现在逐帧观察发现细节非常丰富，怪不得那么爽。<br><img src="/2024/01/18/VFX/Gabriel-Aguiar-Series/VFX-Principles/invoker.gif" alt="卡尔天火"><br>Anticipation就是“使玩家感觉有事将要发生了”。可以简单理解为“技能前摇”。在卡尔的这个例子中，直接表现的就是一道很细的光束从上到下，并且收束的越来越细，地面开始出现光线焦点和波纹扩散。<br><img src="/2024/01/18/VFX/Gabriel-Aguiar-Series/VFX-Principles/image.png" alt="卡尔天火技能前摇"><br>这个阶段可长可短，主要依据是你想将这个效果设计为一个可规避的技能还是一个瞬时效果，总之就是给人以“期待”。</li></ul><p>接下来的Climax就是技能生效的阶段，一般来说这个阶段的持续时间最短，光污染最强，给人感觉最爽。<br><img src="/2024/01/18/VFX/Gabriel-Aguiar-Series/VFX-Principles/image-1.png" alt="卡尔技能生效"><br>逐帧观察可以发现，卡尔技能生效的一瞬间，有一道非常粗的天光从天而降，地面出现灼烧感的贴图，随后地面的光圈瞬间扩大，并伴随爆炸和地面破碎效果，视觉冲击感很强。这里地面叠加了两层贴图，一层表现烧灼感，一层表现破碎感。  </p><p>最后，Dissipation阶段作为这段VFX的收尾，使地面的光圈逐渐消散，然后火焰消散，最后留下破碎的地面。(懒得截图了，自己体会:D)</p><h3 id="Shape"><a href="#Shape" class="headerlink" title="Shape"></a>Shape</h3><p>比起生命周期，其实更加直观的是一个VFX的形状。不同的形状决定了一个VFX看上去究竟是“很有威胁”还是“很柔和”，以及这个VFX效果的属性。比如上面卡尔的天火一看就很痛，但是一些治疗效果看上去就很柔和，这个很好理解。关于形状其实更多的感受是类似于子弹的形状对人感官上的影响，一些尖头的魔法子弹看上去威力会大一点，而一些偏球形的子弹就更加有钝感。<br>总体来说，这一节其实也没有什么好讲的，都是比较直观能感受的东西。</p><h3 id="Contrast"><a href="#Contrast" class="headerlink" title="Contrast"></a>Contrast</h3><p>对比度这个东西其实是平时比较容易忽视的，但是这个因素的确非常重要。因为对比度一定程度上反应了一个VFX的“重要程度”。高对比度往往可以吸引玩家的注意，引导玩家的视线。一般的情形是，低重要性或“不想让人发现”的效果(比如我感觉DOTA2中的莲花就有点看不清)往往会有更低的对比度。<br>不过对比度也不是很好量化，都是凭感觉。一般VFX有大面积的高亮度区域和低亮度区域就可以认为对比度很高，同时具有以上两者对比度更强。<br><img src="/2024/01/18/VFX/Gabriel-Aguiar-Series/VFX-Principles/image-2.png" alt="对比度参考"><br>将VFX转化为灰度图，上图可以作为对比度的参考。越靠近中间的色块对比度越低。</p><h3 id="Color-Theme"><a href="#Color-Theme" class="headerlink" title="Color&amp;Theme"></a>Color&amp;Theme</h3><p>关于颜色和主题，其实也不用说太多，实际上就是不同的颜色和元素会让VFX看起来有不同的感觉。<br><img src="/2024/01/18/VFX/Gabriel-Aguiar-Series/VFX-Principles/image-3.png" alt="不同的调色板和元素"><br>调色板即上图中的一个个纯色圆形组成的有序集合，亮度从第到高，一方面可以反映色相，另一方面可以反映对比度。同时第二列中虽然调色板差不多，但是可以看出上图加了辉光效果，下图加了类似于治疗的元素，让这两个VFX看起来完全不同。调色板和主题元素共同决定一个VFX看起来怎么样，当调色板比较接近的时候，主题元素就决定了一切。如果调换一下这两个VFX的调色板，而不更换主题元素的话，其实看上去也没多大差别。</p>]]></content>
    
    
    <categories>
      
      <category>图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VFX</tag>
      
      <tag>Gabriel Aguiar入门教程</tag>
      
      <tag>Series</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Varjo开发入门</title>
    <link href="/2024/01/15/Collection/Varjo-Development/"/>
    <url>/2024/01/15/Collection/Varjo-Development/</url>
    
    <content type="html"><![CDATA[<h2 id="Varjo开发思维导图"><a href="#Varjo开发思维导图" class="headerlink" title="Varjo开发思维导图"></a>Varjo开发思维导图</h2><p><img src="/2024/01/15/Collection/Varjo-Development/VarjoDevelopment.svg" alt="Varjo开发思维导图"></p>]]></content>
    
    
    <categories>
      
      <category>图形学</category>
      
      <category>VR</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用SDF玩转shadertoy</title>
    <link href="/2024/01/03/Collection/Play-Shadertoy-With-SDF/"/>
    <url>/2024/01/03/Collection/Play-Shadertoy-With-SDF/</url>
    
    <content type="html"><![CDATA[<h1 id="shadertoy是什么"><a href="#shadertoy是什么" class="headerlink" title="shadertoy是什么"></a>shadertoy是什么</h1><p>shadertoy是由<a href="http://www.beautypi.com/">Beautypi</a></p>]]></content>
    
    
    <categories>
      
      <category>图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDF</tag>
      
      <tag>shadertoy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有向距离场(Signed Distance Field, SDF)</title>
    <link href="/2024/01/03/Collection/Signed-Distance-Field-SDF/"/>
    <url>/2024/01/03/Collection/Signed-Distance-Field-SDF/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是有向距离场"><a href="#什么是有向距离场" class="headerlink" title="什么是有向距离场"></a>什么是有向距离场</h2><p>有向距离场是一种隐式的表示曲面的数据结构。具体的形式主要有2D和3D两种，不过这两种本质没啥区别，无非就是维数不同而已，都是使用一系列网格(Grid)填充整个空间，每个网格计算网格中心与距离它最近的一个表面的距离，用这个距离代表这个网格，而“有向”体现在如果网格处于一个封闭物体内，则这个距离为负数，否则为正数。如果刚好位于物体表面，则距离为0。这一大堆网格就构成了一个场，这个场隐式地定义了处于这个场中的物体表面。<br>可以看出网格的密度决定这个场景的精确程度，获取场景中任何一个点的SDF值需要经过双线性或者三线性插值。<br>一开始我看完并理解了这个定义之后，觉得也不过如此，结果没想到这个东西能在图形学中发挥这么大的用处，从随心所欲地绘制2D图形，到字体，到光线步进，到阴影生成等等，感觉这个玩意无处不在，在写这篇文章的时候我对SDF的理解也还是停留在表面，所以这篇文章实际上是一个索引，日后我会逐渐完善SDF的应用，并且在这篇文章中给出对应的其他文章的链接，逐渐补完这块领域。</p><h2 id="使用SDF玩转shadertoy"><a href="#使用SDF玩转shadertoy" class="headerlink" title="使用SDF玩转shadertoy"></a>使用SDF玩转shadertoy</h2><p>在知道shadertoy之后立即听闻了Inigo Quilez(常说的IQ大神)的大名，<a href="https://iquilezles.org/">他的主页</a>中有大量干货，读者有空可以去看看。<br>其中，SDF无论在他的文章还是shadertoy中都有着重要的地位。关于在shadertoy中使用SDF请移步下面这篇文章：  </p><a href="/2024/01/03/Collection/Play-Shadertoy-With-SDF/" title="使用SDF玩转shadertoy">使用SDF玩转shadertoy</a>]]></content>
    
    
    <categories>
      
      <category>图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDF</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ContraNeRF论文笔记</title>
    <link href="/2024/01/02/Collection/ContraNeRF-Paper-Notes/"/>
    <url>/2024/01/02/Collection/ContraNeRF-Paper-Notes/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>图形学</category>
      
      <category>论文</category>
      
      <category>NeRF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Synthetic-to-real Novel View Synthesis</tag>
      
      <tag>Contrastive Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>视差映射</title>
    <link href="/2023/12/31/Collection/Parallax-Mapping/"/>
    <url>/2023/12/31/Collection/Parallax-Mapping/</url>
    
    <content type="html"><![CDATA[<h2 id="最简单版本的视差映射-Parallax-Mapping"><a href="#最简单版本的视差映射-Parallax-Mapping" class="headerlink" title="最简单版本的视差映射(Parallax Mapping)"></a>最简单版本的视差映射(Parallax Mapping)</h2><p>我个人对于视差映射这个东西其实理解了很久，因为网上大部分的博客和资料都没有点明一件事，那就是视差映射这个东西实际上是一个非常经验性的trick，而不是有多少数学上的严谨在里面的。这导致我一直在试图从几何上理解那一套得到uv的offset的过程，结果一直没有想通，后来干脆尝试直接从合理性的角度去理解这一套过程(就是强行解释…)，反倒茅塞顿开。<br>以下是我个人对于视差映射的理解：</p><h3 id="视差映射是为了解决啥问题？"><a href="#视差映射是为了解决啥问题？" class="headerlink" title="视差映射是为了解决啥问题？"></a>视差映射是为了解决啥问题？</h3><p>普通的贴图+法线贴图固然效果已经还算可以接受了，但是这个方案的缺点在于法线贴图这个东西本质上只修改了一个表面的着色信息(法线)，而无法照顾到因为表面凹凸造成的遮挡问题(几何信息)。位移贴图确实可以解决遮挡问题，但是位移贴图对模型的面数有要求，或者位移完做个曲面细分，无论怎么样都需要模型拥有更多的面数，这样增加了性能的开销。  </p><div class="note note-info">            <p>更多的模型细节必然伴随更多的三角形，不可能通过位移顶点白嫖模型细节的呀</p>          </div><p>所以，视差映射这种高级的trick就出来了，其思想就是：<strong>所谓的遮挡，实际上可以看成【被遮挡部分】的贴图被【遮挡部分】的贴图所取代。如何取代呢？就像抹颜料一样，把【遮挡部分】的贴图抹过去</strong>，不完全准确，再借知乎上一个老哥的图来说就是这样：<br><img src="/2023/12/31/Collection/Parallax-Mapping/image-1.png" alt="图1 视差贴图的一种理解&lt;sup id=&quot;fnref:1&quot; class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--rounded&quot; aria-label=&quot;https://zhuanlan.zhihu.com/p/574361162&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;"><br>所谓的y轴范围着色就是这种“把颜料抹过去”的感觉。不过这张图我有个不太接受的说法就是视差映射增加了着色信息。总体的着色信息我认为是没有变的，改变的只有纹理映射的方式。</p><h3 id="视差映射用到了什么？"><a href="#视差映射用到了什么？" class="headerlink" title="视差映射用到了什么？"></a>视差映射用到了什么？</h3><p>简单来考虑，一个几何平面，一张普通的表面贴图，可能还有法线贴图(加了这玩意效果更好)，然后就是一张视差贴图(这个是关键)，视差贴图其实就是高度图做了一个颜色反转，实际上使用的是高度信息。大概长下面这个样子：<br><img src="/2023/12/31/Collection/Parallax-Mapping/image.png" alt="图2 视差贴图"><br>这个视差贴图实际上是一个砖墙的，可以看出突出的部分是黑色(0)，凹陷的地方是白色(1)，先记住这一点很关键。</p><h3 id="如何使用视差贴图？"><a href="#如何使用视差贴图？" class="headerlink" title="如何使用视差贴图？"></a>如何使用视差贴图？</h3><p>从LearnOpenGL上偷了张图：<br><img src="/2023/12/31/Collection/Parallax-Mapping/image-2.png" alt="图3 视差贴图原理"><br>从图中可以看出，B指向A的向量是我们的视线方向，红色不规则的曲线是高度图(视差贴图取反)的高度，B是视线与这个假想高度的交点，A是视线与平面的交点。如果没有视差映射，我们想要显示的就是A点的纹理，但是由于加入了视差映射，按理说整个区域的纹理都该向图中左边的方向偏移，从纹理坐标上反映就是A点的纹理坐标应该对应原本图中右边的点的纹理坐标。这个偏移值(offset)如何确定？实际上这里做了一个假设，就是<br><strong>假设A点的纹理坐标需要对应到B点投影到平面上那个点的纹理坐标</strong><br>不管从可行性还是性能上考虑我们都不可能算出B点的坐标然后投影。所以这里采用了一种替代的方法求出从A指向B的向量P，将P在平面上的投影作为偏移。具体在fragment shader实现，采用切线空间计算，大概的代码就是长这样：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//我们定义了一个叫做ParallaxMapping的函数，它把fragment的纹理坐标和切线空间中的fragment到观察者的方向向量为输入。</span><br><span class="hljs-comment">//这个函数返回经位移的纹理坐标。然后我们使用这些经位移的纹理坐标进行diffuse和法线贴图的采样。</span><br><span class="hljs-comment">//最后fragment的diffuse颜色和法线向量就正确的对应于表面的经位移的位置上了。</span><br><br><span class="hljs-comment">//我们来看看ParallaxMapping函数的内部：</span><br><span class="hljs-type">vec2</span> ParallaxMapping(<span class="hljs-type">vec2</span> texCoords, <span class="hljs-type">vec3</span> viewDir)<br>&#123; <br>    <span class="hljs-comment">//这里采样了视差贴图，只取r分量的原因是视差贴图本来只有灰度信息</span><br>    <span class="hljs-type">float</span> height =  <span class="hljs-built_in">texture</span>(depthMap, texCoords).r;<br>    <span class="hljs-comment">//这里为什么这么算在下面详细解释</span><br>    <span class="hljs-type">vec2</span> p = viewDir.xy / viewDir.z * (height * height_scale);<br>    <span class="hljs-comment">//这里加或者减会改变最终视觉上倾斜的方向，可以自己试</span><br>    <span class="hljs-keyword">return</span> texCoords - p;    <br>&#125;<br></code></pre></td></tr></table></figure><p>这里，<code>viewDir.xy</code>很明显就是p在平面上投影的方向，除以<code>viewDir.z</code>的原因可以想象一下我们的视线越与平面垂直，需要的偏移量越小，视线越与平面平行，需要的偏移量越大，这里除以z其实就是这个作用。然后为啥要乘以height呢？因为视差贴图这样定义高度：<br><img src="/2023/12/31/Collection/Parallax-Mapping/image-3.png" alt="图4 视差贴图定义的高度"><br>我感觉LearnOpenGL这里给出的图有点不对，读者只用关注0.0和1.0的这两根线就行，其他一律参考图3，并且注意到这里给出的p向量和图3是相反的，所以上面的代码给出的是<code>texCoords - p</code>。<br>可以看到，越突出<code>height</code>越接近0，越平<code>height</code>越接近1，因为如果图3中的A点原本就是山峰，我们就无需计算它的纹理坐标偏移，因为它本身就是遮挡别人的，<code>height</code>为0最终得出来的<code>p</code>也为0向量。最后我们还乘了一个<code>height_scale</code>是为了能自己调视差效果的强度。<br>总结：</p><ul><li>视差映射其实和Blinn-Phong光照模型类似，是一个经验性的算法，不要想的太复杂</li><li>视差映射只是尝试去模拟凹凸，并没有改变几何信息。</li></ul><p>然而到这里其实还没有结束，我们注意到成品还有一些瑕疵，如图：<br><img src="/2023/12/31/Collection/Parallax-Mapping/image-4.png" alt="图5 法线贴图vs视差映射"><br>右图的边缘还是有一些看着不和谐的地方，这是因为边缘的uv坐标经过这么一映射，有些超过1或者有些小于0了，只需要做个判断即可：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs glsl">texCoords = ParallaxMapping(fs_in.TexCoords,  viewDir);<br><span class="hljs-keyword">if</span>(texCoords.x &gt; <span class="hljs-number">1.0</span> || texCoords.y &gt; <span class="hljs-number">1.0</span> || texCoords.x &lt; <span class="hljs-number">0.0</span> || texCoords.y &lt; <span class="hljs-number">0.0</span>)<br>    <span class="hljs-keyword">discard</span>;<br></code></pre></td></tr></table></figure><p>最终结果：<br><img src="/2023/12/31/Collection/Parallax-Mapping/image-5.png" alt="图6 视差映射"></p><h2 id="陡峭视差映射-Steep-Parallax-Mapping"><a href="#陡峭视差映射-Steep-Parallax-Mapping" class="headerlink" title="陡峭视差映射(Steep Parallax Mapping)"></a>陡峭视差映射(Steep Parallax Mapping)</h2><p>上面做的视差映射对向量p的大小做了一个不严谨的假设，直接将A点的高度当作了从A到B的距离。如何让视差映射的计算方法更严谨呢？<br>我们需要求得更精确的B点在平面上的投影，这里就可以使用类似零点定理的思想，我稍微改了一下LearnOpenGL中的图：<br><img src="/2023/12/31/Collection/Parallax-Mapping/image-6.png" alt="图7 陡峭视差映射"><br>这个算法从A出发向v向量的方向步进也行，从T0出发向A步进也行，LearnOpenGL里面用的是后者，那我就按照他的来讲，总之目标都是一样的，上图中的B点是我们想找到的点。首先将深度等分，分多少个间隔自行决定，射线从T0出发，每次碰到等分线(上图中为0.2 0.4等等)就停下，求这个点的深度，与当前等分线的值做对比，一旦当前的深度&lt;等分线代表的深度，即为所求的B点。LearnOpenGL给的代码如下，我觉得不太符合我的理解，但是还是贴一下：  </p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec2</span> ParallaxMapping(<span class="hljs-type">vec2</span> texCoords, <span class="hljs-type">vec3</span> viewDir)<br>&#123; <br>    <span class="hljs-comment">// number of depth layers</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> numLayers = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">// calculate the size of each layer</span><br>    <span class="hljs-type">float</span> layerDepth = <span class="hljs-number">1.0</span> / numLayers;<br>    <span class="hljs-comment">// depth of current layer</span><br>    <span class="hljs-type">float</span> currentLayerDepth = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-comment">// the amount to shift the texture coordinates per layer (from vector P)</span><br>    <span class="hljs-type">vec2</span> P = viewDir.xy * height_scale; <br>    <span class="hljs-type">vec2</span> deltaTexCoords = P / numLayers;<br><br>    <span class="hljs-comment">// get initial values</span><br>    <span class="hljs-type">vec2</span>  currentTexCoords     = texCoords;<br>    <span class="hljs-type">float</span> currentDepthMapValue = <span class="hljs-built_in">texture</span>(depthMap, currentTexCoords).r;<br><br>    <span class="hljs-keyword">while</span>(currentLayerDepth &lt; currentDepthMapValue)<br>    &#123;<br>        <span class="hljs-comment">// shift texture coordinates along direction of P</span><br>        currentTexCoords -= deltaTexCoords;<br>        <span class="hljs-comment">// get depthmap value at current texture coordinates</span><br>        currentDepthMapValue = <span class="hljs-built_in">texture</span>(depthMap, currentTexCoords).r;  <br>        <span class="hljs-comment">// get depth of next layer</span><br>        currentLayerDepth += layerDepth;  <br>    &#125;<br><br>    <span class="hljs-keyword">return</span> currentTexCoords;     <br>&#125;<br></code></pre></td></tr></table></figure><p>可以很直观地看到，将深度等分的数量是影响到程序的运行效率的，所以可以很自然地联想到动态调整等分的数量来加速计算：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//规定最大和最小等分层数，具体采用多少层取决于视线和平面有多垂直，视线越和平面垂直，贴图的offset越小</span><br><span class="hljs-comment">//对于很小的offset，我们不需要很精确地求出offset，所以采用比较小的等分层数即可</span><br><span class="hljs-keyword">const</span> <span class="hljs-type">float</span> minLayers = <span class="hljs-number">8</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-type">float</span> maxLayers = <span class="hljs-number">32</span>;<br><span class="hljs-type">float</span> numLayers = <span class="hljs-built_in">mix</span>(maxLayers, minLayers, <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">dot</span>(<span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>), viewDir)));<br></code></pre></td></tr></table></figure><h2 id="视差屏蔽映射-Parallax-Occlusion-Mapping"><a href="#视差屏蔽映射-Parallax-Occlusion-Mapping" class="headerlink" title="视差屏蔽映射(Parallax Occlusion Mapping)"></a>视差屏蔽映射(Parallax Occlusion Mapping)</h2><p>这个玩意就是陡峭视差映射plus，实际上就是在取得结果的点和取得结果之前那个点之间做插值。因为从图7中可以看出，我们最终取得的点是T3，但是实际上应该取在T2和T3之间，可以想象到的一种插值方法就是考虑T3对应的深度和T2的深度哪个离真实的深度最近，近的更可能接近正确的B点，权重大。我给出一个自己的插值公式：</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>t</mi><mn>3</mn><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>a</mi><mi>b</mi><mi>s</mi><mo stretchy="false">(</mo><mi>t</mi><mn>3</mn><mo>−</mo><mi>t</mi><msup><mn>3</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>a</mi><mi>b</mi><mi>s</mi><mo stretchy="false">(</mo><mi>t</mi><mn>3</mn><mo>−</mo><mi>t</mi><msup><mn>3</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>+</mo><mi>a</mi><mi>b</mi><mi>s</mi><mo stretchy="false">(</mo><mi>t</mi><mn>2</mn><mo>−</mo><mi>t</mi><msup><mn>2</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mtext>其中，</mtext><mi>t</mi><mi>i</mi><mtext>为</mtext><mi>T</mi><mi>i</mi><mtext>点对应的等分线代表的深度，</mtext><mi>t</mi><msup><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mtext>为</mtext><mi>T</mi><mi>i</mi><mtext>点对应的深度图的实际深度，即图</mtext><mn>7</mn><mtext>中红色不规则曲线</mtext></mrow><annotation encoding="application/x-tex">weight\_t3 = (1 - abs(t3-t3&#x27;)/(abs(t3-t3&#x27;)+abs(t2-t2&#x27;)))\\其中，ti为Ti点对应的等分线代表的深度，ti&#x27;为Ti点对应的深度图的实际深度，即图7中红色不规则曲线</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">t</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">b</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal">b</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">b</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">为</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">应</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">分</span><span class="mord cjk_fallback">线</span><span class="mord cjk_fallback">代</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">深</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord cjk_fallback">为</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">应</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">深</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">图</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">际</span><span class="mord cjk_fallback">深</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">即</span><span class="mord cjk_fallback">图</span><span class="mord">7</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">红</span><span class="mord cjk_fallback">色</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">规</span><span class="mord cjk_fallback">则</span><span class="mord cjk_fallback">曲</span><span class="mord cjk_fallback">线</span></span></span></span><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/574361162">https://zhuanlan.zhihu.com/p/574361162</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>材质</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/12/30/hello-world/"/>
    <url>/2023/12/30/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
