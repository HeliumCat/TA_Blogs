<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Gabriel Aguiar的VFX系列(二) 火花</title>
    <link href="/TA_Blogs/2024/01/23/VFX-Sparks/"/>
    <url>/TA_Blogs/2024/01/23/VFX-Sparks/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VFX</tag>
      
      <tag>Gabriel Aguiar入门教程</tag>
      
      <tag>Series</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gabriel Aguiar的VFX系列(一) VFX基本直觉</title>
    <link href="/TA_Blogs/2024/01/18/VFX-Principles/"/>
    <url>/TA_Blogs/2024/01/18/VFX-Principles/</url>
    
    <content type="html"><![CDATA[<h2 id="VFX类型"><a href="#VFX类型" class="headerlink" title="VFX类型"></a>VFX类型</h2><p>VFX这个东西其实类型非常单调，基本上就是shader、粒子效果、网格效果、贴图动画的组合。<br>这个部分其实没啥好说的，主要就是建立一个直觉，以及引发一下何为VFX的思考，因为很多VFX也有网格，那为什么不被定义为模型？显然，“有网格的VFX”与几何模型的最主要的区别就是VFX有明显的生命周期以及生命周期的几个阶段，这里就引出下面的VFX五要素。</p><h2 id="VFX五要素"><a href="#VFX五要素" class="headerlink" title="VFX五要素"></a>VFX五要素</h2><p>构成VFX的五大基本要素，每一项都决定了一个VFX的不同之处。</p><h3 id="GamePlay"><a href="#GamePlay" class="headerlink" title="GamePlay"></a>GamePlay</h3><p>说到底VFX还是为GamePlay服务的，在制作一个VFX之前需要知道具体的需求是什么。<br>这里可能说的有点笼统，但是确实是很关键的一件事，只有明确了这一点，才能决定剩下的几个要素。<br>比如是爆炸效果还是治愈效果，决定了效果的持续时间、对比度、形状、调色板等，有时这些需求区别比较大，比如这个例子，但是有一些需求之间的区分就需要仔细斟酌了，比如水和冰，火和岩浆，黄金和蜂蜜这些视觉表现如何做出区分。<br>从大的方向来看，按照逻辑效果来分有伤害类型和治愈类型 按照依附对象来分有环境类型和角色类型等等</p><h3 id="Timing"><a href="#Timing" class="headerlink" title="Timing"></a>Timing</h3><p>所谓的Timing其实就是一个VFX的生命周期，这个很好理解。爆炸特效的生命周期基本都很短，而一些环境光效，治疗效果之类的生命周期大部分都比较长。总体上来说，一个短生命周期的VFX分为以下几个阶段：</p><ul><li>Anticipation</li><li>Climax</li><li>Dissipation<br>这三个阶段都非常有意思。因为最近在玩DOTA2，举个比较经典的例子就是DOTA2卡尔的天火。写这篇文章之前没有仔细看过，现在逐帧观察发现细节非常丰富，怪不得那么爽。<br><img src="/TA_Blogs/2024/01/18/VFX-Principles/invoker.gif" alt="卡尔天火"><br>Anticipation就是“使玩家感觉有事将要发生了”。可以简单理解为“技能前摇”。在卡尔的这个例子中，直接表现的就是一道很细的光束从上到下，并且收束的越来越细，地面开始出现光线焦点和波纹扩散。<br><img src="/TA_Blogs/2024/01/18/VFX-Principles/image.png" alt="卡尔天火技能前摇"><br>这个阶段可长可短，主要依据是你想将这个效果设计为一个可规避的技能还是一个瞬时效果，总之就是给人以“期待”。</li></ul><p>接下来的Climax就是技能生效的阶段，一般来说这个阶段的持续时间最短，光污染最强，给人感觉最爽。<br><img src="/TA_Blogs/2024/01/18/VFX-Principles/image-1.png" alt="卡尔技能生效"><br>逐帧观察可以发现，卡尔技能生效的一瞬间，有一道非常粗的天光从天而降，地面出现灼烧感的贴图，随后地面的光圈瞬间扩大，并伴随爆炸和地面破碎效果，视觉冲击感很强。这里地面叠加了两层贴图，一层表现烧灼感，一层表现破碎感。  </p><p>最后，Dissipation阶段作为这段VFX的收尾，使地面的光圈逐渐消散，然后火焰消散，最后留下破碎的地面。(懒得截图了，自己体会:D)</p><h3 id="Shape"><a href="#Shape" class="headerlink" title="Shape"></a>Shape</h3><p>比起生命周期，其实更加直观的是一个VFX的形状。不同的形状决定了一个VFX看上去究竟是“很有威胁”还是“很柔和”，以及这个VFX效果的属性。比如上面卡尔的天火一看就很痛，但是一些治疗效果看上去就很柔和，这个很好理解。关于形状其实更多的感受是类似于子弹的形状对人感官上的影响，一些尖头的魔法子弹看上去威力会大一点，而一些偏球形的子弹就更加有钝感。<br>总体来说，这一节其实也没有什么好讲的，都是比较直观能感受的东西。</p><h3 id="Contrast"><a href="#Contrast" class="headerlink" title="Contrast"></a>Contrast</h3><p>对比度这个东西其实是平时比较容易忽视的，但是这个因素的确非常重要。因为对比度一定程度上反应了一个VFX的“重要程度”。高对比度往往可以吸引玩家的注意，引导玩家的视线。一般的情形是，低重要性或“不想让人发现”的效果(比如我感觉DOTA2中的莲花就有点看不清)往往会有更低的对比度。<br>不过对比度也不是很好量化，都是凭感觉。一般VFX有大面积的高亮度区域和低亮度区域就可以认为对比度很高，同时具有以上两者对比度更强。<br><img src="/TA_Blogs/2024/01/18/VFX-Principles/image-2.png" alt="对比度参考"><br>将VFX转化为灰度图，上图可以作为对比度的参考。越靠近中间的色块对比度越低。</p><h3 id="Color-Theme"><a href="#Color-Theme" class="headerlink" title="Color&amp;Theme"></a>Color&amp;Theme</h3><p>关于颜色和主题，其实也不用说太多，实际上就是不同的颜色和元素会让VFX看起来有不同的感觉。<br><img src="/TA_Blogs/2024/01/18/VFX-Principles/image-3.png" alt="不同的调色板和元素"><br>调色板即上图中的一个个纯色圆形组成的有序集合，亮度从第到高，一方面可以反映色相，另一方面可以反映对比度。同时第二列中虽然调色板差不多，但是可以看出上图加了辉光效果，下图加了类似于治疗的元素，让这两个VFX看起来完全不同。调色板和主题元素共同决定一个VFX看起来怎么样，当调色板比较接近的时候，主题元素就决定了一切。如果调换一下这两个VFX的调色板，而不更换主题元素的话，其实看上去也没多大差别。</p>]]></content>
    
    
    <categories>
      
      <category>图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VFX</tag>
      
      <tag>Gabriel Aguiar入门教程</tag>
      
      <tag>Series</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Varjo开发入门</title>
    <link href="/TA_Blogs/2024/01/15/Varjo-Development/"/>
    <url>/TA_Blogs/2024/01/15/Varjo-Development/</url>
    
    <content type="html"><![CDATA[<h2 id="Varjo开发思维导图"><a href="#Varjo开发思维导图" class="headerlink" title="Varjo开发思维导图"></a>Varjo开发思维导图</h2><p><img src="/TA_Blogs/2024/01/15/Varjo-Development/VarjoDevelopment.svg" alt="Varjo开发思维导图"></p>]]></content>
    
    
    <categories>
      
      <category>图形学</category>
      
      <category>VR</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用SDF玩转shadertoy</title>
    <link href="/TA_Blogs/2024/01/03/Play-Shadertoy-With-SDF/"/>
    <url>/TA_Blogs/2024/01/03/Play-Shadertoy-With-SDF/</url>
    
    <content type="html"><![CDATA[<p>&#x2F;&#x2F;—————–施工中——————-&#x2F;&#x2F;</p>]]></content>
    
    
    <categories>
      
      <category>图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDF</tag>
      
      <tag>shadertoy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有向距离场(Signed Distance Field, SDF)</title>
    <link href="/TA_Blogs/2024/01/03/Signed-Distance-Field-SDF/"/>
    <url>/TA_Blogs/2024/01/03/Signed-Distance-Field-SDF/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是有向距离场"><a href="#什么是有向距离场" class="headerlink" title="什么是有向距离场"></a>什么是有向距离场</h2><p>有向距离场是一种隐式的表示曲面的数据结构。具体的形式主要有2D和3D两种，不过这两种本质没啥区别，无非就是维数不同而已，都是使用一系列网格(Grid)填充整个空间，每个网格计算网格中心与距离它最近的一个表面的距离，用这个距离代表这个网格，而“有向”体现在如果网格处于一个封闭物体内，则这个距离为负数，否则为正数。如果刚好位于物体表面，则距离为0。这一大堆网格就构成了一个场，这个场隐式地定义了处于这个场中的物体表面。<br>可以看出网格的密度决定这个场景的精确程度，获取场景中任何一个点的SDF值需要经过双线性或者三线性插值。<br>一开始我看完并理解了这个定义之后，觉得也不过如此，结果没想到这个东西能在图形学中发挥这么大的用处，从随心所欲地绘制2D图形，到字体，到光线步进，到阴影生成等等，感觉这个玩意无处不在，在写这篇文章的时候我对SDF的理解也还是停留在表面，所以这篇文章实际上是一个索引，日后我会逐渐完善SDF的应用，并且在这篇文章中给出对应的其他文章的链接，逐渐补完这块领域。</p><h2 id="使用SDF玩转shadertoy"><a href="#使用SDF玩转shadertoy" class="headerlink" title="使用SDF玩转shadertoy"></a>使用SDF玩转shadertoy</h2><p>在知道shadertoy之后立即听闻了Inigo Quilez(常说的IQ大神)的大名，<a href="https://iquilezles.org/">他的主页</a>中有大量干货，读者有空可以去看看。<br>其中，SDF无论在他的文章还是shadertoy中都有着重要的地位。关于在shadertoy中使用SDF请移步下面这篇文章：<br><a href="https://heliumcat.github.io/TA_Blogs/2024/01/03/Play-Shadertoy-With-SDF/">使用SDF玩转shadertoy</a></p>]]></content>
    
    
    <categories>
      
      <category>图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDF</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ContraNeRF论文笔记</title>
    <link href="/TA_Blogs/2024/01/02/ContraNeRF-Paper-Notes/"/>
    <url>/TA_Blogs/2024/01/02/ContraNeRF-Paper-Notes/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>图形学</category>
      
      <category>论文</category>
      
      <category>NeRF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Synthetic-to-real Novel View Synthesis</tag>
      
      <tag>Contrastive Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>视差映射</title>
    <link href="/TA_Blogs/2023/12/31/Parallax-Mapping/"/>
    <url>/TA_Blogs/2023/12/31/Parallax-Mapping/</url>
    
    <content type="html"><![CDATA[<h2 id="最简单版本的视差映射-Parallax-Mapping"><a href="#最简单版本的视差映射-Parallax-Mapping" class="headerlink" title="最简单版本的视差映射(Parallax Mapping)"></a>最简单版本的视差映射(Parallax Mapping)</h2><p>我个人对于视差映射这个东西其实理解了很久，因为网上大部分的博客和资料都没有点明一件事，那就是视差映射这个东西实际上是一个非常经验性的trick，而不是有多少数学上的严谨在里面的。这导致我一直在试图从几何上理解那一套得到uv的offset的过程，结果一直没有想通，后来干脆尝试直接从合理性的角度去理解这一套过程(就是强行解释…)，反倒茅塞顿开。<br>以下是我个人对于视差映射的理解：</p><h3 id="视差映射是为了解决啥问题？"><a href="#视差映射是为了解决啥问题？" class="headerlink" title="视差映射是为了解决啥问题？"></a>视差映射是为了解决啥问题？</h3><p>普通的贴图+法线贴图固然效果已经还算可以接受了，但是这个方案的缺点在于法线贴图这个东西本质上只修改了一个表面的着色信息(法线)，而无法照顾到因为表面凹凸造成的遮挡问题(几何信息)。位移贴图确实可以解决遮挡问题，但是位移贴图对模型的面数有要求，或者位移完做个曲面细分，无论怎么样都需要模型拥有更多的面数，这样增加了性能的开销。  </p><div class="note note-info">            <p>更多的模型细节必然伴随更多的三角形，不可能通过位移顶点白嫖模型细节的呀</p>          </div><p>所以，视差映射这种高级的trick就出来了，其思想就是：<strong>所谓的遮挡，实际上可以看成【被遮挡部分】的贴图被【遮挡部分】的贴图所取代。如何取代呢？就像抹颜料一样，把【遮挡部分】的贴图抹过去</strong>，不完全准确，再借知乎上一个老哥的图来说就是这样：<br><img src="/TA_Blogs/2023/12/31/Parallax-Mapping/image-1.png" alt="图1 视差贴图的一种理解&lt;sup id=&quot;fnref:1&quot; class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--rounded&quot; aria-label=&quot;https://zhuanlan.zhihu.com/p/574361162&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;"><br>所谓的y轴范围着色就是这种“把颜料抹过去”的感觉。不过这张图我有个不太接受的说法就是视差映射增加了着色信息。总体的着色信息我认为是没有变的，改变的只有纹理映射的方式。</p><h3 id="视差映射用到了什么？"><a href="#视差映射用到了什么？" class="headerlink" title="视差映射用到了什么？"></a>视差映射用到了什么？</h3><p>简单来考虑，一个几何平面，一张普通的表面贴图，可能还有法线贴图(加了这玩意效果更好)，然后就是一张视差贴图(这个是关键)，视差贴图其实就是高度图做了一个颜色反转，实际上使用的是高度信息。大概长下面这个样子：<br><img src="/TA_Blogs/2023/12/31/Parallax-Mapping/image.png" alt="图2 视差贴图"><br>这个视差贴图实际上是一个砖墙的，可以看出突出的部分是黑色(0)，凹陷的地方是白色(1)，先记住这一点很关键。</p><h3 id="如何使用视差贴图？"><a href="#如何使用视差贴图？" class="headerlink" title="如何使用视差贴图？"></a>如何使用视差贴图？</h3><p>从LearnOpenGL上偷了张图：<br><img src="/TA_Blogs/2023/12/31/Parallax-Mapping/image-2.png" alt="图3 视差贴图原理"><br>从图中可以看出，B指向A的向量是我们的视线方向，红色不规则的曲线是高度图(视差贴图取反)的高度，B是视线与这个假想高度的交点，A是视线与平面的交点。如果没有视差映射，我们想要显示的就是A点的纹理，但是由于加入了视差映射，按理说整个区域的纹理都该向图中左边的方向偏移，从纹理坐标上反映就是A点的纹理坐标应该对应原本图中右边的点的纹理坐标。这个偏移值(offset)如何确定？实际上这里做了一个假设，就是<br><strong>假设A点的纹理坐标需要对应到B点投影到平面上那个点的纹理坐标</strong><br>不管从可行性还是性能上考虑我们都不可能算出B点的坐标然后投影。所以这里采用了一种替代的方法求出从A指向B的向量P，将P在平面上的投影作为偏移。具体在fragment shader实现，采用切线空间计算，大概的代码就是长这样：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//我们定义了一个叫做ParallaxMapping的函数，它把fragment的纹理坐标和切线空间中的fragment到观察者的方向向量为输入。</span><br><span class="hljs-comment">//这个函数返回经位移的纹理坐标。然后我们使用这些经位移的纹理坐标进行diffuse和法线贴图的采样。</span><br><span class="hljs-comment">//最后fragment的diffuse颜色和法线向量就正确的对应于表面的经位移的位置上了。</span><br><br><span class="hljs-comment">//我们来看看ParallaxMapping函数的内部：</span><br><span class="hljs-type">vec2</span> ParallaxMapping(<span class="hljs-type">vec2</span> texCoords, <span class="hljs-type">vec3</span> viewDir)<br>&#123; <br>    <span class="hljs-comment">//这里采样了视差贴图，只取r分量的原因是视差贴图本来只有灰度信息</span><br>    <span class="hljs-type">float</span> height =  <span class="hljs-built_in">texture</span>(depthMap, texCoords).r;<br>    <span class="hljs-comment">//这里为什么这么算在下面详细解释</span><br>    <span class="hljs-type">vec2</span> p = viewDir.xy / viewDir.z * (height * height_scale);<br>    <span class="hljs-comment">//这里加或者减会改变最终视觉上倾斜的方向，可以自己试</span><br>    <span class="hljs-keyword">return</span> texCoords - p;    <br>&#125;<br></code></pre></td></tr></table></figure><p>这里，<code>viewDir.xy</code>很明显就是p在平面上投影的方向，除以<code>viewDir.z</code>的原因可以想象一下我们的视线越与平面垂直，需要的偏移量越小，视线越与平面平行，需要的偏移量越大，这里除以z其实就是这个作用。然后为啥要乘以height呢？因为视差贴图这样定义高度：<br><img src="/TA_Blogs/2023/12/31/Parallax-Mapping/image-3.png" alt="图4 视差贴图定义的高度"><br>我感觉LearnOpenGL这里给出的图有点不对，读者只用关注0.0和1.0的这两根线就行，其他一律参考图3，并且注意到这里给出的p向量和图3是相反的，所以上面的代码给出的是<code>texCoords - p</code>。<br>可以看到，越突出<code>height</code>越接近0，越平<code>height</code>越接近1，因为如果图3中的A点原本就是山峰，我们就无需计算它的纹理坐标偏移，因为它本身就是遮挡别人的，<code>height</code>为0最终得出来的<code>p</code>也为0向量。最后我们还乘了一个<code>height_scale</code>是为了能自己调视差效果的强度。<br>总结：</p><ul><li>视差映射其实和Blinn-Phong光照模型类似，是一个经验性的算法，不要想的太复杂</li><li>视差映射只是尝试去模拟凹凸，并没有改变几何信息。</li></ul><p>然而到这里其实还没有结束，我们注意到成品还有一些瑕疵，如图：<br><img src="/TA_Blogs/2023/12/31/Parallax-Mapping/image-4.png" alt="图5 法线贴图vs视差映射"><br>右图的边缘还是有一些看着不和谐的地方，这是因为边缘的uv坐标经过这么一映射，有些超过1或者有些小于0了，只需要做个判断即可：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs glsl">texCoords = ParallaxMapping(fs_in.TexCoords,  viewDir);<br><span class="hljs-keyword">if</span>(texCoords.x &gt; <span class="hljs-number">1.0</span> || texCoords.y &gt; <span class="hljs-number">1.0</span> || texCoords.x &lt; <span class="hljs-number">0.0</span> || texCoords.y &lt; <span class="hljs-number">0.0</span>)<br>    <span class="hljs-keyword">discard</span>;<br></code></pre></td></tr></table></figure><p>最终结果：<br><img src="/TA_Blogs/2023/12/31/Parallax-Mapping/image-5.png" alt="图6 视差映射"></p><h2 id="陡峭视差映射-Steep-Parallax-Mapping"><a href="#陡峭视差映射-Steep-Parallax-Mapping" class="headerlink" title="陡峭视差映射(Steep Parallax Mapping)"></a>陡峭视差映射(Steep Parallax Mapping)</h2><p>上面做的视差映射对向量p的大小做了一个不严谨的假设，直接将A点的高度当作了从A到B的距离。如何让视差映射的计算方法更严谨呢？<br>我们需要求得更精确的B点在平面上的投影，这里就可以使用类似零点定理的思想，我稍微改了一下LearnOpenGL中的图：<br><img src="/TA_Blogs/2023/12/31/Parallax-Mapping/image-6.png" alt="图7 陡峭视差映射"><br>这个算法从A出发向v向量的方向步进也行，从T0出发向A步进也行，LearnOpenGL里面用的是后者，那我就按照他的来讲，总之目标都是一样的，上图中的B点是我们想找到的点。首先将深度等分，分多少个间隔自行决定，射线从T0出发，每次碰到等分线(上图中为0.2 0.4等等)就停下，求这个点的深度，与当前等分线的值做对比，一旦当前的深度&lt;等分线代表的深度，即为所求的B点。LearnOpenGL给的代码如下，我觉得不太符合我的理解，但是还是贴一下：  </p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec2</span> ParallaxMapping(<span class="hljs-type">vec2</span> texCoords, <span class="hljs-type">vec3</span> viewDir)<br>&#123; <br>    <span class="hljs-comment">// number of depth layers</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> numLayers = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">// calculate the size of each layer</span><br>    <span class="hljs-type">float</span> layerDepth = <span class="hljs-number">1.0</span> / numLayers;<br>    <span class="hljs-comment">// depth of current layer</span><br>    <span class="hljs-type">float</span> currentLayerDepth = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-comment">// the amount to shift the texture coordinates per layer (from vector P)</span><br>    <span class="hljs-type">vec2</span> P = viewDir.xy * height_scale; <br>    <span class="hljs-type">vec2</span> deltaTexCoords = P / numLayers;<br><br>    <span class="hljs-comment">// get initial values</span><br>    <span class="hljs-type">vec2</span>  currentTexCoords     = texCoords;<br>    <span class="hljs-type">float</span> currentDepthMapValue = <span class="hljs-built_in">texture</span>(depthMap, currentTexCoords).r;<br><br>    <span class="hljs-keyword">while</span>(currentLayerDepth &lt; currentDepthMapValue)<br>    &#123;<br>        <span class="hljs-comment">// shift texture coordinates along direction of P</span><br>        currentTexCoords -= deltaTexCoords;<br>        <span class="hljs-comment">// get depthmap value at current texture coordinates</span><br>        currentDepthMapValue = <span class="hljs-built_in">texture</span>(depthMap, currentTexCoords).r;  <br>        <span class="hljs-comment">// get depth of next layer</span><br>        currentLayerDepth += layerDepth;  <br>    &#125;<br><br>    <span class="hljs-keyword">return</span> currentTexCoords;     <br>&#125;<br></code></pre></td></tr></table></figure><p>可以很直观地看到，将深度等分的数量是影响到程序的运行效率的，所以可以很自然地联想到动态调整等分的数量来加速计算：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//规定最大和最小等分层数，具体采用多少层取决于视线和平面有多垂直，视线越和平面垂直，贴图的offset越小</span><br><span class="hljs-comment">//对于很小的offset，我们不需要很精确地求出offset，所以采用比较小的等分层数即可</span><br><span class="hljs-keyword">const</span> <span class="hljs-type">float</span> minLayers = <span class="hljs-number">8</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-type">float</span> maxLayers = <span class="hljs-number">32</span>;<br><span class="hljs-type">float</span> numLayers = <span class="hljs-built_in">mix</span>(maxLayers, minLayers, <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">dot</span>(<span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>), viewDir)));<br></code></pre></td></tr></table></figure><h2 id="视差屏蔽映射-Parallax-Occlusion-Mapping"><a href="#视差屏蔽映射-Parallax-Occlusion-Mapping" class="headerlink" title="视差屏蔽映射(Parallax Occlusion Mapping)"></a>视差屏蔽映射(Parallax Occlusion Mapping)</h2><p>这个玩意就是陡峭视差映射plus，实际上就是在取得结果的点和取得结果之前那个点之间做插值。因为从图7中可以看出，我们最终取得的点是T3，但是实际上应该取在T2和T3之间，可以想象到的一种插值方法就是考虑T3对应的深度和T2的深度哪个离真实的深度最近，近的更可能接近正确的B点，权重大。我给出一个自己的插值公式：</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>t</mi><mn>3</mn><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>a</mi><mi>b</mi><mi>s</mi><mo stretchy="false">(</mo><mi>t</mi><mn>3</mn><mo>−</mo><mi>t</mi><msup><mn>3</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>a</mi><mi>b</mi><mi>s</mi><mo stretchy="false">(</mo><mi>t</mi><mn>3</mn><mo>−</mo><mi>t</mi><msup><mn>3</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>+</mo><mi>a</mi><mi>b</mi><mi>s</mi><mo stretchy="false">(</mo><mi>t</mi><mn>2</mn><mo>−</mo><mi>t</mi><msup><mn>2</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mtext>其中，</mtext><mi>t</mi><mi>i</mi><mtext>为</mtext><mi>T</mi><mi>i</mi><mtext>点对应的等分线代表的深度，</mtext><mi>t</mi><msup><mi>i</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mtext>为</mtext><mi>T</mi><mi>i</mi><mtext>点对应的深度图的实际深度，即图</mtext><mn>7</mn><mtext>中红色不规则曲线</mtext></mrow><annotation encoding="application/x-tex">weight\_t3 = (1 - abs(t3-t3&#x27;)/(abs(t3-t3&#x27;)+abs(t2-t2&#x27;)))\\其中，ti为Ti点对应的等分线代表的深度，ti&#x27;为Ti点对应的深度图的实际深度，即图7中红色不规则曲线</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">t</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">b</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal">b</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">b</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">为</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">应</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">分</span><span class="mord cjk_fallback">线</span><span class="mord cjk_fallback">代</span><span class="mord cjk_fallback">表</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">深</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal">t</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord cjk_fallback">为</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">应</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">深</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">图</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">际</span><span class="mord cjk_fallback">深</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">即</span><span class="mord cjk_fallback">图</span><span class="mord">7</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">红</span><span class="mord cjk_fallback">色</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">规</span><span class="mord cjk_fallback">则</span><span class="mord cjk_fallback">曲</span><span class="mord cjk_fallback">线</span></span></span></span><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/574361162">https://zhuanlan.zhihu.com/p/574361162</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>材质</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/TA_Blogs/2023/12/30/hello-world/"/>
    <url>/TA_Blogs/2023/12/30/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
